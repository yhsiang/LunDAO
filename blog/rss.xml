<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>LunDAO Blog</title>
        <link>https://lundao.tech/blog</link>
        <description>LunDAO Blog</description>
        <lastBuildDate>Sun, 22 May 2022 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[Hardhat tracer]]></title>
            <link>https://lundao.tech/blog/hardhat-tracer</link>
            <guid>hardhat-tracer</guid>
            <pubDate>Sun, 22 May 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[如何利用 Hardhat tracer 套件來解析特定的交易]]></description>
            <content:encoded><![CDATA[<p>本文章將展示如何使用知名開發框架 Hardhat 的附加元件「hardhat-tracer」，令開發者能視覺化地了解特定 transaction 運作過程，加速開發流程與降低除錯難度。</p><p>開發大型智能合約（smart contract）專案的過程中，一定少不了與其他合約做互動，例如：DEX 聚合器（aggregator）的開發團隊，就必須熟悉如何與 DEX 合約直接互動。因此，如何取得一款好用的工具能快速、簡要、視覺化地呈現出執行一條 transaction 過程，包含所有 message call、event log 等，就顯得格外重要，本文將介紹幾款工具可以達成此一目的。隨著目前 smart contract 專案日益複雜，開發者對這方面的需求蓬勃發展，因此新套件推陳出新；非常歡迎熱心的讀者前往 LunDAO <a href="https://github.com/lun-dao/LunDAO/issues">Issues</a> 或 <a href="https://github.com/lun-dao/LunDAO/discussions">Discussions</a> 頁面與大家分享。</p><h2>安裝環境與注意事項</h2><p>本文<strong>不會</strong>提供 Hardhat 的安裝指引或基礎教學，相關內容敬請參考 LunDAO 其他文章（例如：<a href="../2022-04-24-hardhat-intro/index.md">Hardhat 簡介</a>）。</p><p>以下列出筆者實際測試能夠運行本文步驟的軟體條件，實際情況必不限於此配置敬請讀者參酌考量。</p><ul><li>Software<ul><li>OS<ul><li>Windows 10 Pro 21H1 (w/o WSL)</li><li>Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-1053-raspi aarch64)</li></ul></li><li>Node.js v16.14.2</li><li>Yarn 1.22.18</li><li>hardhat-tracer v1.1.0-<strong>rc.6</strong></li></ul></li></ul><p>由於本文後續會涉及使用 Hardhat Network 的內容，因此強烈推薦讀者應具備此部分操作經驗；LunDAO 亦已有此系列教學文章，歡迎多加閱讀並與大家討論。</p><h2>使用 hardhat-tracer 套件</h2><p>由於 hardhat-tracer 會需要向 Ethereum node 發送 <code>debug_traceTransaction</code>、<code>eth_getStorageAt</code>、<code>eth_getCode</code> 等 JSON-RPC method 撈取歷史資料，因此務必確認您已經連接到歸檔節點（archive node）。您可以自行架設<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> archive node，或使用節點供應商提供的服務；在筆者撰文的當下，Alchemy 仍有提供免費 Ethereum mainnet archive node，因此筆者選擇使用此服務。</p><p>假設我們想知道這個 transaction<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 的詳細過程（View on <a href="https://etherscan.io/tx/0xca722f52d743bfecb555993d64439aa6e6653914ad87073fb27bfbe42f67d62c">Etherscan</a>）：</p><blockquote><p>0xca722f52d743bfecb555993d64439aa6e6653914ad87073fb27bfbe42f67d62c</p></blockquote><p>關於 <code>hardhat.config.js</code> 的內容，以下僅列出與此套件有關的欄位，其他細節請參考相關說明文件。</p><pre><code class="language-Javascript">require(&quot;hardhat-tracer&quot;);

module.exports = {
    networks: {
        mainnet: {
          url: process.env.AlchemyURL,
        },
        hardhat: {
            forking: {
                url: process.env.AlchemyURL,
            }
        },
    },
};
</code></pre><ol><li>在資料夾底下安裝 hardhat-tracer 套件（假設該資料夾已安裝完成 Hardhat）</li></ol><pre><code>$ yarn add hardhat-tracer
</code></pre><ol start="2"><li>執行以下指令（注意要指定 <code>--network</code> 參數<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup>讓 Hardhat 能連結到正確的網路）</li></ol><pre><code>$ yarn hardhat --network &quot;hardhat&quot; trace --hash &quot;0xca722f52d743bfecb555993d64439aa6e6653914ad87073fb27bfbe42f67d62c&quot;
</code></pre><ol start="3"><li>等候數分鐘之後，就可以看到 terminal 顯示以下資訊</li></ol><pre><code>$ yarn hardhat --network &quot;hardhat&quot; trace --hash &quot;0xca722f52d743bfecb555993d64439aa6e6653914ad87073fb27bfbe42f67d62c&quot;
yarn run v1.22.18

Seems that it is taking time to fetch the state involved.
Please note that this process may take several minutes.
A lot of eth_getStorageAt requests are currently being made to the rpc.

CALL UnknownContractAndFunction(to=0x3b7157e5e732863170597790b4c005436572570f, input=0xf6326fb3, ret=0x)
   EVENT &lt;UnknownContract 0x3b7157E5E732863170597790b4c005436572570F&gt;.UnknownEvent(0x000000000000000000000000000000000000000000000000008e1bc9bf040000, [0x8752a472e571a816aea92eec8dae9baf628e840f4929fbcc2d155e6233ff68a7, 0x000000000000000000000000e760f546a925a4cfdcc62a674d14cc42a676c06f, 0x000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2])
   CALL UnknownContractAndFunction(to=0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2, input=0xd0e30db0, ret=0x)
      EVENT &lt;UnknownContract 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&gt;.UnknownEvent(0x000000000000000000000000000000000000000000000000008e1bc9bf040000, [0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c, 0x0000000000000000000000003b7157e5e732863170597790b4c005436572570f])
</code></pre><ol start="4"><li>以上解析結果為 hardhat-tracer 預設解析模式，僅顯示 event log 和 function call；若您想要一併了解 state variables 的讀寫情況（<a href="https://www.evm.codes/#54"><code>SLOAD</code></a>、<a href="https://www.evm.codes/#55"><code>SSTORE</code></a>），那麼可以多加上 <code>--fulltrace</code> 參數</li></ol><pre><code>$ yarn hardhat --network &quot;hardhat&quot; trace --fulltrace --hash &quot;0xca722f52d743bfecb555993d64439aa6e6653914ad87073fb27bfbe42f67d62c&quot;
yarn run v1.22.18

Seems that it is taking time to fetch the state involved.
Please note that this process may take several minutes.
A lot of eth_getStorageAt requests are currently being made to the rpc.

CALL UnknownContractAndFunction(to=0x3b7157e5e732863170597790b4c005436572570f, input=0xf6326fb3, ret=0x)
   SLOAD 0x0000000000000000000000000000000000000000000000000000000000000001 =&gt; (0x0000000000000000000000000000000000000000000000000000000000000001)
   SSTORE 0x0000000000000000000000000000000000000000000000000000000000000001 &lt;= (0x0000000000000000000000000000000000000000000000000000000000000002)
   SLOAD 0x0000000000000000000000000000000000000000000000000000000000000005 =&gt; (0x0000000000000000000000000000000000000000000000000000000062196d80)
   SLOAD 0x0000000000000000000000000000000000000000000000000000000000000006 =&gt; (0x00000000000000000000000000000000000000000000000000000000621d6200)
   SLOAD 0x5cc08dfcef394bb3e1501dd9c602b313a910bc96e6e3b9f14c10c5608560cb26 =&gt; (0x0000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419)
   SLOAD 0xe49870035e3714aceb7aadebead18a1e5a95f2d32ab68a7ffb99d8329af3a56d =&gt; (0x0000000000000000000000000000000000000000000000000000000000000000)
   SLOAD 0xe49870035e3714aceb7aadebead18a1e5a95f2d32ab68a7ffb99d8329af3a56d =&gt; (0x0000000000000000000000000000000000000000000000000000000000000000)
   SSTORE 0xe49870035e3714aceb7aadebead18a1e5a95f2d32ab68a7ffb99d8329af3a56d &lt;= (0x000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)
   SLOAD 0xe49870035e3714aceb7aadebead18a1e5a95f2d32ab68a7ffb99d8329af3a56e =&gt; (0x0000000000000000000000000000000000000000000000000000000000000000)
   SSTORE 0xe49870035e3714aceb7aadebead18a1e5a95f2d32ab68a7ffb99d8329af3a56e &lt;= (0x000000000000000000000000000000000000000000000000008e1bc9bf040000)
   SLOAD 0x5cc08dfcef394bb3e1501dd9c602b313a910bc96e6e3b9f14c10c5608560cb27 =&gt; (0x00000000000000000000000000000000000000000000025e69bc17dc01d0d07f)
   SSTORE 0x5cc08dfcef394bb3e1501dd9c602b313a910bc96e6e3b9f14c10c5608560cb27 &lt;= (0x00000000000000000000000000000000000000000000025e6a4a33a5c0d4d07f)
   EVENT &lt;UnknownContract 0x3b7157E5E732863170597790b4c005436572570F&gt;.UnknownEvent(0x000000000000000000000000000000000000000000000000008e1bc9bf040000, [0x8752a472e571a816aea92eec8dae9baf628e840f4929fbcc2d155e6233ff68a7, 0x000000000000000000000000e760f546a925a4cfdcc62a674d14cc42a676c06f, 0x000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2])
   CALL UnknownContractAndFunction(to=0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2, input=0xd0e30db0, ret=0x)
      SLOAD 0x42dd4d28989ab1eee96fb196b01de4c17c0f145bc71364b95645949f1f133408 =&gt; (0x00000000000000000000000000000000000000000000025e69bc17dc01d0d07f)
      SSTORE 0x42dd4d28989ab1eee96fb196b01de4c17c0f145bc71364b95645949f1f133408 &lt;= (0x00000000000000000000000000000000000000000000025e6a4a33a5c0d4d07f)
      EVENT &lt;UnknownContract 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&gt;.UnknownEvent(0x000000000000000000000000000000000000000000000000008e1bc9bf040000, [0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c, 0x0000000000000000000000003b7157e5e732863170597790b4c005436572570f])
   SSTORE 0x0000000000000000000000000000000000000000000000000000000000000001 &lt;= (0x0000000000000000000000000000000000000000000000000000000000000001)
</code></pre><p>到這邊為止，我們已經成功使用 hardhat-tracer 套件來解析 transaction 了。然而，以上資訊在合約地址、event 名稱等部分，以原始型態呈現造成版面冗長且混亂，不利於我們閱讀。</p><p>所幸 hardhat-tracer 套件提供 address name tag 功能，讓我們可以自定義什麼地址要以什麼名稱標籤來顯示。另外，hardhat-tracer 也支援匯入已知合約的程式碼或 <code>interface</code>，讓解析結果可以自動帶入該合約來顯示。</p><p>根據上述結果，我們可發現執行 transaction 的過程會與兩個合約互動 — <code>0x3b7157E5E732863170597790b4c005436572570F</code> 和 <code>0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2</code>；因此，我們可以前往 Etherscan 來查詢這些合約的 ABI，再搭配 <a href="https://bia.is/tools/abi2solidity/">ABI2Solidity</a> 來把 JSON format 轉成 solidity <code>interface</code> format。</p><ol start="5"><li>按照一般使用 Hardhat 的習慣，我們在 <code>contracts</code> 子目錄底下創建這份 solidity code <sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup></li></ol><pre><code class="language-solidity">// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.7;

// Assume that 0x3b7157E5E732863170597790b4c005436572570F is named as &quot;TokenSale&quot;.
interface TokenSale {
  function WETH (  ) external view returns ( address );
  function allocateTokensForSale ( uint256 _amount ) external;
  function availableTokens (  ) external view returns ( uint256 );
  function deposit ( address _token, uint256 _amount ) external;
  function depositETH (  ) external;
  function enableWithdrawals (  ) external;
  function finalizeRaise (  ) external;
  function getSupportedTokens (  ) external view returns ( address[] memory );
  function getTokenOracle ( address _token ) external view returns ( address );
  function getTokenOracles (  ) external view returns ( address[] memory oracles );
  function getUserClaimableTokens ( address _user ) external view returns ( uint256 );
  function owner (  ) external view returns ( address );
  function renounceOwnership (  ) external;
  function saleSchedule (  ) external view returns ( uint256 startTimestamp, uint256 endTimestamp );
  function saleToken (  ) external view returns ( address );
  function setSaleSchedule ( uint256 _start, uint256 _end ) external;
  function totalRaisedUSD (  ) external view returns ( uint256 );
  function transferOwnership ( address newOwner ) external;
  function transferToTreasury (  ) external;
  function treasury (  ) external view returns ( address );
  function userAccounts ( address ) external view returns ( address token, uint256 depositedAmount );
  function withdraw (  ) external;
  function withdrawalsEnabled (  ) external view returns ( bool );
}

//  Assume that 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 is named as &quot;WrappedEther&quot;.
interface WrappedEther {
  function name (  ) external view returns ( string memory );
  function approve ( address guy, uint256 wad ) external returns ( bool );
  function totalSupply (  ) external view returns ( uint256 );
  function transferFrom ( address src, address dst, uint256 wad ) external returns ( bool );
  function withdraw ( uint256 wad ) external;
  function decimals (  ) external view returns ( uint8 );
  function balanceOf ( address ) external view returns ( uint256 );
  function symbol (  ) external view returns ( string memory );
  function transfer ( address dst, uint256 wad ) external returns ( bool );
  function deposit (  ) external payable;
  function allowance ( address, address ) external view returns ( uint256 );
}
</code></pre><ol start="6"><li>執行 <code>$ yarn hardhat compile</code> 編譯所有 solidity codes</li><li>進入 <code>hardhat.config.js</code> 新增以下欄位，讓特定 address 以開發者自定義的名稱標籤（name tage）顯示</li></ol><pre><code class="language-Javascript">module.exports = {
    tracer: {
        nameTags: {
            [&quot;0x3b7157E5E732863170597790b4c005436572570F&quot;]: &quot;TokenSale&quot;,
            [&quot;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&quot;]: &quot;WrappedEther&quot;,
            [&quot;0xe760f546a925a4cfdcc62a674d14cc42a676c06f&quot;]: &quot;Someone&quot;,
        }
    },
};
</code></pre><ol start="8"><li>重新執行 hardhat-tracer 指令，我們可以看到可讀性變得很高（比起 step 3 來說）</li></ol><pre><code>$ yarn hardhat --network &quot;hardhat&quot; trace --hash &quot;0xca722f52d743bfecb555993d64439aa6e6653914ad87073fb27bfbe42f67d62c&quot;
yarn run v1.22.18

Seems that it is taking time to fetch the state involved.
Please note that this process may take several minutes.
A lot of eth_getStorageAt requests are currently being made to the rpc.

CALL TokenSale.depositETH{value: 40000000000000000}()
   EVENT TokenSale.Deposited(depositor=[Someone], token=[WrappedEther], amount=40000000000000000)
   CALL WrappedEther.deposit{value: 40000000000000000}()
      EVENT WrappedEther.Deposit(dst=[TokenSale], wad=40000000000000000)
</code></pre><h2>使用圖形化介面工具</h2><p>除了使用上述套件之外，目前也有許多網站提供免費解析 transaction 的服務。</p><p>假設我們想知道以下這筆 transaction<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 的執行過程（View on <a href="https://etherscan.io/tx/0x4a7c2dabf8695f18835ff2aeb133df1a89f0af3759b1832e493bee10e721d998">Etherscan</a>）：</p><blockquote><p>0x4a7c2dabf8695f18835ff2aeb133df1a89f0af3759b1832e493bee10e721d998</p></blockquote><h3>Etherscan Parity Trace</h3><p><img src="./etherscan-parity-trace-1.png" alt="etherscan-parity-trace-1"/></p><p>如上圖所示，點擊「Parity Trace」選項之後，將開啟如同下圖的另一個分頁。</p><p><img src="./etherscan-parity-trace-2.png" alt="etherscan-parity-trace-2"/></p><p>此方法呈現的效果較不視覺化，然而應為目前最通用的分析方式；不只 Etherscan 有支援 Parity VM tracer，其它的 block explorer 網站應能找到類似功能。</p><h3>Etherscan Transaction Decoder</h3><p><img src="./etherscan-txn-decoder-1.png" alt="etherscan-txn-decoder-1"/></p><p>如上圖所示，點擊「Transaction Decoder」選項之後，將開啟如同下圖的另一個分頁。</p><p><img src="./etherscan-txn-decoder-2.png" alt="etherscan-txn-decoder-2"/></p><p>可以看到 Etherscan 已經分門別類地將執行 transaction 的過程會發出的 event log、message call 等重要事件，以條列表格的方式呈現出來。</p><h3>EthTx.info</h3><p>此服務以 Python 撰寫的<a href="https://github.com/ethtx/ethtx">開源軟體</a>所建立，並由 <a href="https://tokenflow.live/">Token Flow</a> 團隊所維護，在筆者撰文當下為免費公開讓所有開發者自由使用。</p><ol><li>前往 <a href="https://ethtx.info/">https://ethtx.info/</a></li><li>選擇正確的網路（此例為 ETH mainnet），並輸入對應的 transaction hash</li><li>按下「Decode now」按鈕，並靜候數分鐘（可能因網站壅塞度而有不同）</li></ol><p><img src="./ethtx-info.png" alt="ethtx-info"/></p><h3>Tenderly</h3><p>前往 <a href="https://dashboard.tenderly.co/explorer">Tenderly</a> 官網，在搜尋框當中輸入 transaction hash 並按下送出查詢，即可獲得如下圖所示的網頁。</p><p><img src="tenderly.png" alt="tenderly"/></p><p>由於 Tenderly 不只提供分析 transaction 的功能，還有需多實用的其它工具（例如：simulator、local transaction analysis）；若讀者有興趣的話，建議可註冊一個免費帳號。</p><h2>Related resources</h2><ul><li>Hardhat<ul><li><a href="https://hardhat.org/config/">https://hardhat.org/config/</a></li></ul></li><li>Alchemy<ul><li><a href="https://www.alchemy.com/">https://www.alchemy.com/</a></li><li><a href="https://docs.alchemy.com/alchemy/enhanced-apis/debug-api">https://docs.alchemy.com/alchemy/enhanced-apis/debug-api</a></li></ul></li><li>Smart Contracts at Etherscan<ul><li><a href="https://etherscan.io/address/0x3b7157E5E732863170597790b4c005436572570F">https://etherscan.io/address/0x3b7157E5E732863170597790b4c005436572570F</a></li><li><a href="https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2">https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2</a></li></ul></li><li>hardhat-tracer<ul><li><a href="https://www.npmjs.com/package/hardhat-tracer">https://www.npmjs.com/package/hardhat-tracer</a></li><li><a href="https://github.com/zemse/hardhat-tracer">https://github.com/zemse/hardhat-tracer</a></li></ul></li><li>ABI2Solidity<ul><li><a href="https://bia.is/tools/abi2solidity/">https://bia.is/tools/abi2solidity/</a></li><li><a href="https://github.com/maxme/abi2solidity">https://github.com/maxme/abi2solidity</a></li></ul></li><li>Etherscan Transaction Decoder<ul><li><a href="https://etherscan.io/tx-decoder">https://etherscan.io/tx-decoder</a></li></ul></li><li>EthTx.info<ul><li><a href="https://github.com/ethtx/ethtx">https://github.com/ethtx/ethtx</a></li></ul></li><li>Tenderly<ul><li><a href="https://dashboard.tenderly.co/explorer">https://dashboard.tenderly.co/explorer</a></li></ul></li></ul><div class="footnotes"><hr/><ol><li id="fn-2">需要準備大容量 SSD，其餘硬體條件較無嚴苛限制（樹梅派 4B 即足以運行 Go-Ethereum）<a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-1">筆者隨機挑選的 transaction hash，並沒有任何特殊用意<a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-3">由於 <code>debug_traceTransaction</code> 屬於 Alchemy 需付費的 API method，因此若讀者使用 Growth 以上的方案，那麼您可以直接以 <code>--network &quot;mainnet&quot;</code> 連結 Alchemy；另一種免費的替代方案則為改用 Hardhat Network 來解析 transaction，只對 Alchemy 發送 <code>eth_getStorageAt</code>、<code>eth_getCode</code> 等請求，因此筆者在此以 <code>--network &quot;hardhat&quot;</code> 參數舉例<a href="#fnref-3" class="footnote-backref">↩</a></li><li id="fn-4">如果讀者知道待解析 transaction 的所有互動合約 source code，那麼推薦您直接把那些程式碼加入 <code>contracts</code> 子目錄底下做編譯，這樣能讓 hardhat-tracer 顯示結果擁有最高的可讀性；若無法取得所有 source code，則只使用合約們 ABI 所轉成的 <code>interface</code> 做編譯亦可。<a href="#fnref-4" class="footnote-backref">↩</a></li></ol></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hardhat 簡介]]></title>
            <link>https://lundao.tech/blog/hardhat-intro</link>
            <guid>hardhat-intro</guid>
            <pubDate>Sun, 24 Apr 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[Hardhat 是一套開發智能合約用的開發工具，本篇文章會介紹 Hardhat 的基礎使用方式。]]></description>
            <content:encoded><![CDATA[<p>撰寫一般程式語言如 node.js 時，通常只要準備執行環境與編輯器就可以開始進行開發了。而開發 Solidity 則有些許不同，由於程式會需要跑在區塊鏈網路上，所以這個執行環境會比較複雜，會需要透過 RPC 連接並且佈署到區塊鏈網路上面並且執行、除錯與測試。</p><p>Hardhat 就是開發 Solidity 智能合約時所需要的開發工具，除了內建一個開發用的本地區塊鏈網路 Hardhat Network 外還打造了一套 plugin 系統讓許多跟區塊鏈相關的工具可以整合到 hardhat 讓開發者可以更容易進行開發、除錯、測試等，同時 Hardhat 針對 TypeScript 的支援比起其他類似工具還要優良，這在撰寫測試時會有很大的幫助。</p><p>本文將會簡介 hardhat 的用法與跟其他工具比較的優勢。</p><p>文中的運行環境統一都是 Node.js v16 運行在 macOS 環境，其他作業系統可能會有些微的不同，但差別應該不大。</p><h2>設定範例專案</h2><p>為了說明 hardhat 的各種功能，在這邊先設定一個由 hardhat 提供的一個範本專案，請先建立一個目錄 <code>hardhat-sample</code> 並且在裡面執行 hardhat 指令：</p><pre><code class="language-shell">$ mkdir hardhat-sample
$ cd hardhat-sample
$ npx hardhat
</code></pre><p>npx 是一個由 node.js 提供的指令可以執行由 node.js 撰寫的 CLI 程序，如果該 CLI 程序還沒安裝，他會詢問你是否要安裝並且從自動下載，所以首次執行時會詢問你是否要安裝 hardhat，按下確認即可繼續，接下來會看到 hardhat 的導引畫面。</p><p><img src="hardhat-cli-init.png" alt="Hardhat cli initial"/>
選擇 <code>Create a basic sample project</code>，並且在接下來的問題都按 Enter 選擇預設值，hardhat 會開始安裝相關的套件，稍等一段時間會安裝完畢。</p><p>當安裝完畢之後再輸入一次 <code>npx hardhat</code> 就會顯示以下輸出：</p><pre><code>$ npx hardhat

Hardhat version 2.9.2

... skip

AVAILABLE TASKS:

  accounts  Prints the list of accounts
  check     Check whatever you need
  clean     Clears the cache and deletes all artifacts
  compile   Compiles the entire project, building all artifacts
  console   Opens a hardhat console
  flatten   Flattens and prints contracts and their dependencies
  help      Prints this message
  node      Starts a JSON-RPC server on top of Hardhat Network
  run       Runs a user-defined script after compiling the project
  test      Runs mocha tests

To get help for a specific task run: npx hardhat help [task]
</code></pre><p>到這邊就產生了一個範例用的專案了，除了可以看到 hardhat 有提供許多指令可以使用包含編譯、測試等等外，範例專案也包含了一些佈署用的腳本、範本智能合約以及測試。</p><h2>Hardhat 設定檔</h2><p>專案的根目錄底下會有一個 <code>hardhat.config.js</code> 檔案，這是設置 hardhat 的地方，你可以在這邊啟用 hardhat plugin、加入一些常用的工作變成一個新的 hardhat 指令，也可以在這邊設定編譯器與連接到不同的網路。</p><p>預設的 <code>hardhat.config.js</code> 如下：</p><pre><code class="language-javascript">// 1. import plugin
require(&quot;@nomiclabs/hardhat-waffle&quot;);

// 2. add tasks
task(&quot;accounts&quot;, &quot;Prints the list of accounts&quot;, async (taskArgs, hre) =&gt; {
  const accounts = await hre.ethers.getSigners();

  for (const account of accounts) {
    console.log(account.address);
  }
});

// 3. export configuration
module.exports = {
  solidity: &quot;0.8.4&quot;,
};
</code></pre><p>註解所標示的三大部分，各別是啟用 <code>hatdhat-waffle</code> plugin、加入一個新指令跟設定 hardhat 所用的編譯器。</p><h2>編譯 Solidity 檔案</h2><p>執行 <code>npx hardhat compile</code> 時，在 <code>contracts</code> 目錄的智能合約會被編譯，而編譯後的產物 (Artifacts) 會寫到 <code>artifacts</code> 目錄底下，比如說編譯結束後會產生 <code>artifacts/contracts/Greeter.sol/Greeter.json</code> 這個就是合約的 abi，當佈署到 Ethereum 網路後就可以用這份檔案來跟合約互動。</p><p>編譯 Solidity 檔案的編譯器版本可以在 <code>hardhat.config.js</code> 裡面設定，上面的範例指定 <code>solidity: &quot;0.8.4&quot;</code> 是最基礎的設定，還有一些也可以設定的項目：</p><ul><li>最佳化：設定要不要開啟編譯最佳化以及最佳化的程度，預設是關閉最佳化<sup id="fnref-註1"><a href="#fn-註1" class="footnote-ref">註1</a></sup></li><li>EVM 版本：EVM 在不同的分岔後會多出一些新的功能或格式上的差異，這邊也可以指定</li></ul><p>設定的方法如下，更詳細的資訊可以參考 hardhat 官方網站裡面的 <a href="https://hardhat.org/guides/compile-contracts.html">Compiling your contracts</a> 一節。</p><pre><code class="language-javascript">solidity: {
  version: &quot;0.5.15&quot;,
  settings: {
    optimizer: {
      enabled: true, // 啟用最佳化
      runs: 200 // 最佳化的評估方式
    },
    evmVersion: &quot;istanbul&quot; // 可以選擇 instanbul, berlin, london 等
  }
}
</code></pre><p>而 <code>runs</code> 參數是開發者評估這個合約預估會執行幾次，提供給編譯器執行最佳化時的參考依據，可以閱讀 <a href="https://discord.com/channels/927177880318922802/927177880318922807/967717928290107392">LunDAO discord 討論</a>。</p><p>如果你遇到編譯器與 solidity 檔案中所指定的版本沒有相符時，也可以指定多重編譯器版本，比如說你自己的合約用 0.6，但是你所引用的 openzeppelin 合約則是 0.5，此時可以在 Hardhat 設定檔裡面指定多種不同版本的 solidity。</p><pre><code class="language-javascript">module.exports = {
  solidity: {
    compilers: [
      {
        version: &quot;0.5.5&quot;,
      },
      {
        version: &quot;0.6.7&quot;
      },
    ],
  },
};
</code></pre><h2>執行測試</h2><p>執行 <code>npx hardhat test</code> 會開始執行測試，執行測試前 hardhat 會先將所有的智能合約編譯完畢後才執行，在 <code>test/</code> 目錄底下的所有 JavaScript 測試檔案都會被執行。</p><p>我們這邊對照著 solidity 與測試檔案一起看：</p><pre><code class="language-javascript">// Greeter.sol
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import &quot;hardhat/console.sol&quot;;

contract Greeter {
    string private greeting;

    constructor(string memory _greeting) {
        console.log(&quot;Deploying a Greeter with greeting:&quot;, _greeting);
        greeting = _greeting;
    }

    function greet() public view returns (string memory) {
        return greeting;
    }

    function setGreeting(string memory _greeting) public {
        console.log(&quot;Changing greeting from &#x27;%s&#x27; to &#x27;%s&#x27;&quot;, greeting, _greeting);
        greeting = _greeting;
    }
}
</code></pre><pre><code class="language-javascript">// sample-test.js
const { expect } = require(&quot;chai&quot;);
const { ethers } = require(&quot;hardhat&quot;);

describe(&quot;Greeter&quot;, function () {
  it(&quot;Should return the new greeting once it&#x27;s changed&quot;, async function () {
    const Greeter = await ethers.getContractFactory(&quot;Greeter&quot;);
    const greeter = await Greeter.deploy(&quot;Hello, world!&quot;);
    await greeter.deployed();

    expect(await greeter.greet()).to.equal(&quot;Hello, world!&quot;);

    const setGreetingTx = await greeter.setGreeting(&quot;Hola, mundo!&quot;);

    // wait until the transaction is mined
    await setGreetingTx.wait();

    expect(await greeter.greet()).to.equal(&quot;Hola, mundo!&quot;);
  });
});

</code></pre><p>測試檔案會把 Greeter 合約透過 <code>ethers.getContractFactory(&quot;Greeter&quot;)</code> 取得 Factory 合約，並且透過  <code>Greeter.deploy(&quot;Hello, world!&quot;)</code> 佈署到本地的測試網路裡面，到等佈署成功後就開始進行測試。</p><p>這個本地測試網路 Hardhat Network 會在測試結束之後銷毀所有測試所佈署上去的合約與狀態。</p><h2>佈署</h2><p>Hardhat 官方雖然沒有提供佈署工具，但是可以透過 <code>hardhat script</code> 指令做到。下達以下指令之後可以佈署到內建的 Hardhat network：</p><pre><code class="language-shell">$ npx hardhat run ./scripts/sample-script.js 
Deploying a Greeter with greeting: Hello, Hardhat!
Greeter deployed to: 0x5FbDB2315678afecb367f032d93F642f64180aa3
</code></pre><p>但由於是佈署於本地的開發用網路 Hardhat Network，而這個區塊鏈網路在指令執行結束後就會銷毀所有在上面佈署的合約與狀態，所以除了執行指令的當下可以呼叫函式測試外沒有其他可以測試的方法。</p><p>此時可以在 <code>hardhat.config.js</code> 裡面加入一個 Ethereum 的網路如 mainnet 或是測試網路 Rinkeby, Ropsten 來進行測試。</p><p>比如說你可以先用 MetaMask 在測試網路 Rinkeby 建立一個帳號，取得測試用的 ETH 並且匯出註記詞。然後到 <a href="https://infura.io/">Infura</a> 或是 <a href="https://www.alchemy.com/">alchemy</a> 申請一個 API 來存取 Rinkeby，並且改設定檔 <code>hardhat.config.js</code>：</p><pre><code class="language-javascript">module.exports = {
  solidity: &quot;0.8.4&quot;,
  networks: {
    rinkeby: {
        url: &quot;https://rinkeby.infura.io/v3/&lt;INFURA_PROJECT_ID&gt;&quot;,
        accounts: {
            mnemonic: &quot;&lt;YOUR_MNEMONIC&gt;&quot;,
        },
        chainId: 4, // 可以查看 https://chainlist.org/
    }
  },
};
</code></pre><p>設定完畢後就可以用相同的指令但加入 <code>--network</code> 佈署到 Rinkeby 網路上面：</p><pre><code class="language-shell">$ npx hardhat run --network rinkeby ./scripts/sample-script.js
</code></pre><p>這樣這份 Greeter 合約就會被佈署到 Rinkeby 測試網路上面了。這邊的範例給的比較簡易，但實際上通常會把可抽換的資訊如 <code>INFURA_PROJECT_ID</code> 或 <code>MNEMONIC</code> 透過環境變數傳入，並且用 <a href="https://github.com/motdotla/dotenv">dotenv</a> 模組管理。</p><h2>比較</h2><p>跟 Hardhat 類似的工具有幾個如 Truffle 與 Remix，但是 Hardhat 跟其他的工具比較有些額外的好處。</p><h3>與 Truffle 比較</h3><p><a href="https://trufflesuite.com/">Truffle</a> 原生內建了 web3.js 函式庫，不過舊的版本裡面混用了不相容的兩種 web3.js 函式庫，開發上經常會很困惑。不過筆者很久沒用 Truffle 了，或許現在已經沒有這個問題，而兩種 web3.js 版本導致的問題是不知道怎麼用 web3 函式庫也帶出了下一個優勢 - TypeScript 支援。</p><p>Hardhat 原生就是採用 TypeScript 開發，這在採用 Hardhat 進行智能合約開發時，清楚的型別在製作開發工具以及撰寫測試上面能夠更有效率，這在後續的文章會在解釋如何設定 TypeScript 以及他所提供的優勢。</p><p>另外有一些 Truffle 提供的工具我一直都沒找到好用的地方，比如說 Truffle 的鏈上 migration 機制都沒有合適合理的使用方式，而重新將 <code>mocha</code> 的 <code>describe()</code> 包裝成 <code>contract()</code> 提供的 <a href="https://trufflesuite.com/docs/truffle/testing/writing-tests-in-javascript/#use-contract-instead-of-describe">clear-room feature</a> 一直都沒感受到特別實用的地方，而全域的 <code>artifacts.require()</code> 也讓人感到有些困惑。</p><p>相較起來 Hardhat 通常都是比較明確的撰寫方式如下面的例子，我覺得比較容易理解與閱讀。</p><pre><code class="language-javascript">// truffle&#x27;s implicit global function `artifacts`
const MetaCoin = artifacts.require(&quot;MetaCoin&quot;); // where does artifacts come from?
MetaCoin.deployed()

// hardhat&#x27;s explicit function
const { ethers } = require(&quot;hardhat&quot;); // explicitly import via hardhat
const Greeter = await ethers.getContractFactory(&quot;Greeter&quot;);
</code></pre><h3>與 Remix IDE 比較</h3><p><a href="https://remix-project.org/">Remix</a> 比較適合快速的測試與除錯，但以網頁作為基礎開發的開發套件比較不適合團隊開發使用。一般來說如果想要快速測試時，Remix 會更加的合用，但是如果想要放在 Github 讓團隊一起協作開發，Hardhat 或是 Truffle 會比較適合。</p><h3>新工具 foundry</h3><p><a href="https://github.com/foundry-rs/foundry">Foundry</a> 是 LunDAO 的 discord 群組上面最近討論的工具，看起來比起 Hardhat 把 Hardhat Network 跟框架打包在一起，Foundry 提供了一個更獨立的開發工具，看起來是個不錯的新選擇，或許之後也會撰文介紹。</p><h2>結論</h2><p>如同上面的比較，筆者自己是比較偏好 Hardhat，同時也在團隊中採用了超過兩年的時間，在 Perpetual Protocol V1 到 V2 的轉換也還是採用了相同工具，這也讓 hardhat 成為了團隊的必備工具。</p><p>而 Hardhat 上面豐富的工具如 <a href="https://github.com/wighawag/hardhat-deploy">hardhat-deploy</a>, <a href="https://hardhat.org/plugins/nomiclabs-hardhat-etherscan.html">hardhat-etherscan</a> 與 <a href="https://github.com/cgewecke/hardhat-gas-reporter">hardhat-gas-reporter</a> 等等都讓開發工作能夠更順利的進行。</p><p>然而 hardhat 提供的彈性框架有時候在開發上也會造成一些困擾，接下來 Hardhat 系列文章將會更深入的解釋 Hardhat 結構與原理，當在大量使用 Hardhat 可以更明白發生了什麼事情以及如何解決使用 Hardhat 會遇到的問題。</p><div class="footnotes"><hr/><ol><li id="fn-註1">關閉最佳化時仍會有部分的最佳化，請參考 <a href="https://discord.com/channels/927177880318922802/927177880318922807/967723565623423006">LunDAO discord 討論</a><a href="#fnref-%E8%A8%BB1" class="footnote-backref">↩</a></li></ol></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Diamond 101 (1)]]></title>
            <link>https://lundao.tech/blog/diamond101</link>
            <guid>diamond101</guid>
            <pubDate>Wed, 20 Apr 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[EIP-2535 Diamond Contract]]></description>
            <content:encoded><![CDATA[<p>本文為 Diamond 101 系列的第一篇文章，將解釋什麼是可升級合約、常見的實作以及不同實作之間的設計。</p><h2>Proxy 的組成</h2><p><img src="./transparent_proxy_func.jpeg"/></p><p>可升級合約顧名思義就是可以更新邏輯的合約，實作大多基於 Proxy。Proxy 是一種 Solidity 的 design pattern，將資料與邏輯分開處理，只要能替換掉邏輯，就能升級。</p><h3>Delegatecall</h3><p>首先需要先來補充一點背景知識。目前所有的 Proxy 都是 <code>delegatecall</code> 的應用。簡單說明 <code>delegatecall</code> 就是以別的合約的函式來操作發出 <code>delegatecall</code> 的合約的 storage。而一般的合約調用則是以自己的函式操作自己的 storage。舉例來說，當 A 合約對 B 合約調用 <code>delegatecall</code> 時，B 合約的函式會被調用，但是對 storage 的寫入都會執行 A 合約上。附上<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5a75065659a65e65bb04890192e3a4bcb7917fff/contracts/proxy/Proxy.sol#L22-L45">常見的 delegatecall 實作</a>。</p><p>Delegatecall 也衍生出不少有趣的 EIP，例如 <a href="https://eips.ethereum.org/EIPS/eip-1167">EIP-1167</a>，以最小的成本複製一個合約。</p><h3>fallback 與 receive</h3><p>有關合約調用的交易 (transaction) 的 data 欄位不會空著，前面 4 個 bytes 為 function selector，用來讓 EVM 知道要執行合約中的哪段 bytecode。要是沒有 function selector 或是 function selector 不在合約中怎麼辦？這時則會看合約有沒有實作 <code>fallback</code> 或是 <code>receive</code>，兩者觸發的條件如下：</p><ul><li><code>fallback</code>:<ul><li>合約中沒有對應的 function selector</li><li>沒有 receive 時</li></ul></li><li><code>receive</code>:<ul><li>交易的 data 為空 (不管 value 為多少)</li></ul></li></ul><p>Proxy 合約中不會紀錄邏輯合約 (logic contract) 每一個 function selector，就會利用 fallback 的特性處理所有的合約調用，將所有的合約調用都 delegatecall 至邏輯合約 (logic contract)。可以來看一下 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Proxy.sol">Openzeppelin</a> 提供的實作，就是 delegatecall 跟 fallback, receive 的組合拳。</p><h2>Transparent Proxy</h2><p><img src="./transparent_proxy.jpeg"/></p><p>架構圖如上，來看一下 Openzeppelin 的介紹</p><blockquote><p>The way we deal with this problem is via the transparent proxy pattern. The goal of a transparent proxy is to be indistinguishable by a user from the actual logic contract.</p></blockquote><p>這是何意呢？主要是要讓使用者跟邏輯合約 (logic contract) 緊緊連結在一起，不過這樣寫也很讓人難懂。簡單來說就是使用者所發起的合約調用都要以 delegatecall 調用邏輯合約 (logic contract)，而 admin 所發起的合約調用永遠不會到邏輯合約。</p><p>示意圖如下</p><table><thead><tr><th>msg.sender</th><th>owner()</th><th>upgradeTo()</th><th>transfer()</th></tr></thead><tbody><tr><td>admin</td><td>returns proxy.owner</td><td>upgrades proxy</td><td>reverts</td></tr><tr><td>user</td><td>returns ERC20 owner</td><td>reverts</td><td>sends ERC20 transfer</td></tr></tbody></table><p>Openzeppelin 採用 EIP-1967 作為實作。實作上，Proxy 裡面的每個管理 proxy 的 function 都會加上身份驗證的流程，只讓 admin 可以調用。但是為何還要一個而 ProxyAdmin 呢？ProxyAdmin 主要用途是為了執行查詢的用途還有讓 owner 解放。</p><p>舉個例子，<code>admin()</code> 應該要是個 <code>view function</code> 但是因為 fallback 的關係不能標示 <code>view</code>，需要利用另外一個合約再包裝一層才能標示 <code>view</code>。此外 admin 也可能同時是 user，把權限交給 ProxyAdmin 同時有更好的 function interface 可以調用，也可以讓 admin 解開限制。</p><p><strong>Proxy 中 admin function 的舉例</strong></p><pre><code class="language-javascript">modifier ifAdmin() {
    if (msg.sender == _getAdmin()) {
        _;
    } else {
        _fallback();
    }
}

function admin() external ifAdmin returns (address admin_) {
    admin_ = _getAdmin();
}
</code></pre><p><strong>ProxyAdmin 中對 admin function 的封裝</strong></p><p>跟 <code>staticcall</code> 一起使用，才能標示為 <code>view</code></p><pre><code class="language-javascript">function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {
    (bool success, bytes memory returndata) = address(proxy).staticcall(hex&quot;f851a440&quot;);
    require(success);
    return abi.decode(returndata, (address));
}
</code></pre><h2>UUPS</h2><p><img src="./uups_proxy.jpeg"/></p><p>UUPS 的規格和介面是基於 EIP-1822，不過 Openzeppelin 也是和 EIP-1967 搭配作為實作。Transparent Proxy 最大的差異在做 upgrade 的函式同樣也放在邏輯合約中，讓 Proxy 只留 fallback 和 receive。升級合約也需要透過 delegatecall 調用邏輯合約。合約架構更為精簡，不用額外的身份驗證或是額外的 Admin 合約。</p><h2>Diamond</h2><p><img src="./diamond.jpeg"/></p><p>Diamond 怎麼升級跟 Transparent Proxy 跟 UUPS 截然不同。Transparent Proxy 跟 UUPS 每次更新都需要將整份合約更新，除了不需要更新的部分也連帶更新了，而且因為合約大小有上限 (EIP-170) 也不能在單個合約一直增加新的邏輯。所以有人提出了 EIP-2535，主要是建立一張表來註冊不同的 function selector。有趣的地方在於可以註冊不同合約的 function selector。也就是說 delegatecall 可以調用的合約不只限於一個。除了彈性變大之外，也可以只新增或是修改其中一個 function selector。</p><h2>Reference</h2><ul><li>EIPS<ul><li><a href="https://eips.ethereum.org/EIPS/eip-7">EIP-7 Delegatecall</a></li><li><a href="https://eips.ethereum.org/EIPS/eip-170">EIP-170 Contract code size limit</a></li><li><a href="https://eips.ethereum.org/EIPS/eip-1167">EIP-1167 Minimal Proxy Contract</a><ul><li>進階閱讀: <a href="https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/">Deep dive into the Minimal Proxy contract</a></li></ul></li><li><a href="https://eips.ethereum.org/EIPS/eip-1822">EIP-1822 Universal Upgradeable Proxy Standard (UUPS)</a></li><li><a href="https://eips.ethereum.org/EIPS/eip-1967">EIP-1967 Standard Proxy Storage Slots</a></li><li><a href="https://eips.ethereum.org/EIPS/eip-2535">EIP-2535 Diamonds, Multi-Facet Proxy</a></li></ul></li><li><a href="https://blog.soliditylang.org/2020/03/26/fallback-receive-split/">Solidity 0.6.x features: fallback and receive functions</a></li><li><a href="https://blog.openzeppelin.com/the-transparent-proxy-pattern/">OpenZeppelin Blog: The transparent proxy pattern</a></li><li><a href="https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-iii-the-function-selector-6a9b6886ea49/">Deconstructing a Solidity Contract — Part III: The Function Selector</a></li><li><a href="https://medium.com/taipei-ethereum-meetup/uups-proxies-%E4%BD%BF%E7%94%A8%E6%96%87-6210c81a946f">UUPS Proxies 使用文</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hardhat mainnet forking：主網分叉 (1)]]></title>
            <link>https://lundao.tech/blog/hardhat-forking-1</link>
            <guid>hardhat-forking-1</guid>
            <pubDate>Wed, 23 Mar 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[如何利用 Hardhat 進行主網分叉]]></description>
            <content:encoded><![CDATA[<p>本文章將展示怎麼使用知名開發工具 Hardhat 的主網分叉（mainnet forking），令開發者可任意指定欲分叉的區塊鏈高度，並與 Hardhat 內建的自定義 testnet（Hardhat Network）結合，享受最高仿真度、最簡便的開發環境。</p><p>在 Ethereum 開發 Dapp 少不了撰寫智能合約（smart contract）；除了使用 Go Ethereum（Geth）、OpenEthereum 等工具自建一條 local testnet，並將合約部屬在上面之外，還可將合約部屬到各大公開測試網（testnet）<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>。然而，這些方法雖然都使用與主網（mainnet）幾乎相同的<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>程式碼當作 L1 底層，但是與直接部屬在 mainnet 最大的差異就是：你幾乎無法讓你的 Dapp 與其他知名合約、DEX 做互動。</p><p>DeFi 之所以在近年受到全球矚目，其中一個原因莫過於其高度的互操作性（interoperability）；各個合約之間可以透過程式呼叫，輕鬆地與彼此互動，達成傳統金融所無法企及的巨大靈活能力。</p><p>然而，如果你正在開發的 Dapp/DeFi 專案，無法在極度仿真的環境當中，通過完整的測試即貿然上線，則此服務將暴露於巨大風險之下。</p><p>部屬合約於 (local) testnet 當中，為求最精緻的模擬環境，你將會耗費極大心力逐一複製所有第三方合約、DEX 的程式碼，並重新佈署於模擬環境當中，這完全不是一個可行的方法。</p><p>Hardhat 的說明文件是這麼介紹 mainnet forking：</p><blockquote><p>You can start an instance of Hardhat Network that forks mainnet. <strong>This means that it will simulate having the same state as mainnet</strong>, but it will work as a local development network. <sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup></p></blockquote><p>本文章將帶領各位讀者熟悉 mainnet forking 的使用方法，並在另一篇文章當中舉幾個例子讓讀者能體會 mainnet forking 的方便性，以期各位讀者都能善用此工具。</p><h2>背景知識與環境</h2><p>Mainnet forking 背後的運作機制，概念上就是模擬一個仿造 Ethereum mainnet 的 local testnet，讓開發者誤以為自己是跟 mainnet 互動。</p><p>當開發者呼叫合約或發送 tx 時，如果該「仿造版」local testnet 查無資訊（該資訊可能是紀錄在某個歷史 block 當中），則 Hardhat 套件轉向歸檔節點（archive node）詢問資訊的內容，並將回傳的結果經過適當包裝後丟給開發者。因此，開發者必需主動提供兩個條件：(1) archive node (2) 指定的區塊高度（以此高度為基準劃分出何謂歷史 block）。</p><p>本文<strong>不會</strong>提供 Hardhat 與其他相關套件的安裝指引，相關操作細節可以參考 LunDAO 其他教學文章。若您已知道如何使用 Hardhat 部屬 ERC-20 合約，則本文深度恰巧適合您。以下為筆者已測試能夠成功運行本文章步驟的軟硬體條件，請讀者參酌使用。</p><ul><li>Software<ul><li>Windows<ul><li>OS：Windows 10 Pro 21H1 (w/o WSL)</li><li>nodejs v14.17.4</li><li>yarn 1.22.17</li></ul></li><li>Linux<ul><li>OS：Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-1053-raspi aarch64)</li><li>其他同 Windows 軟體配置</li></ul></li></ul></li><li>Hardware<ul><li>基本上無限制，下列為經過測試可行的組合</li><li>Windows：Intel Core i7-10510U (16GB) with 4G LTE cellular hotspot</li><li>Linux：Raspberry Pi 4B (4GB) with 1Gbps network</li></ul></li></ul><h2>重要必備條件</h2><p>由於 mainnet forking 的運作過程需與 archive node 作互動；因此，<strong>你必需準備好 archive node</strong> 並將 Hardhat 連接上它。最直白地方式即透過 Geth、OpenEthereum 等工具自架節點<sup id="fnref-5"><a href="#fn-5" class="footnote-ref">5</a></sup>，或可使用市面上知名的數家 SaaS 節點供應商之服務<sup id="fnref-6"><a href="#fn-6" class="footnote-ref">6</a></sup>。本文為求過程輕鬆好學習，以下將搭配 Alchemy 提供的服務。</p><p>另外，由於 Hardhat Network 是 EVM-compatible blockchain，因此理論上任何 EVM-compatible chain 的歸檔節點皆有機會使用 mainnet forking，但實際上可能與 Ethereum mainnet 相比有所限制，筆者僅另外使用過 Polygon mainnet 亦可順利運作。</p><h2>Step 1：建置環境</h2><p>目標：成功啟動 Hardhat Network</p><ol><li>新增一個空白資料夾「<code>hardhat_fork</code>」</li></ol><pre><code class="language-Shell">$ mkdir hardhat_fork
$ cd hardhat_fork
</code></pre><ol start="2"><li>安裝必備的 JavaScript 套件<ul><li>為求所有讀者都能在第一次操作時成功完成，本文將所有套件已指定版本號安裝</li><li>作者建議讀者學會之後，以使用最新 stable version 為佳</li></ul></li></ol><pre><code class="language-Shell">$ yarn init # 沒有想更動的部分，就按 Enter 鍵帶過即可
...
$ yarn add dotenv@16.0.0
$ yarn add hardhat@2.8.4
$ yarn add @nomiclabs/hardhat-waffle@2.0.2
$ yarn add @nomiclabs/hardhat-web3@2.0.0
$ yarn add @nomiclabs/hardhat-ethers@2.0.5
$ yarn add web3@1.7.0
$ yarn add ethers@5.5.4
...
</code></pre><ol start="3"><li>啟動 Hardhat Network 初始化設定</li></ol><pre><code class="language-Shell">$ yarn hardhat
yarn run v1.22.15
888    888                      888 888               888
888    888                      888 888               888
888    888                      888 888               888
8888888888  8888b.  888d888 .d88888 88888b.   8888b.  888888
888    888     &quot;88b 888P&quot;  d88&quot; 888 888 &quot;88b     &quot;88b 888
888    888 .d888888 888    888  888 888  888 .d888888 888
888    888 888  888 888    Y88b 888 888  888 888  888 Y88b.
888    888 &quot;Y888888 888     &quot;Y88888 888  888 &quot;Y888888  &quot;Y888

Welcome to Hardhat v2.8.4

? What do you want to do? …
  Create a basic sample project
  Create an advanced sample project
  Create an advanced sample project that uses TypeScript
▸ Create an empty hardhat.config.js # 請選擇這個選項，並按 Enter
  Quit

$ ls
hardhat.config.js  node_modules  package.json  yarn.lock
</code></pre><ol start="4"><li>你可以發現 <code>hardhat_fork</code> 資料夾底下多了一個名為 <code>hardhat.config.js</code> 的檔案；它就是用來調整 Hardhat Network 和其他 hardhat 套件運作模式的重要參數檔。</li></ol><h2>Step 2：調整 <code>hardhat.config.js</code></h2><p>目標：設定進行 mainnet forking 所需的相關參數</p><ol><li>在 <code>hardhat_fork</code> 資料夾，新增一個空白檔案叫做 <code>.env</code>，並以文字編輯器將以下內容插入其中<ul><li>記得先前往 Alchemy 註冊帳號，並創立一個空白 app 專案（預設可存取 archive node）</li></ul></li></ol><pre><code>Mainnet = &quot;https://eth-mainnet.alchemyapi.io/v2/&lt;your_Alchemy_key&gt;&quot;
</code></pre><ol start="2"><li>使用任何文字編輯器，對 <code>hardhat.config.js</code> 進行編輯，將檔案改成以下樣子（可以直接複製、貼上，取代全部檔案內容）</li></ol><pre><code class="language-js">require(&quot;@nomiclabs/hardhat-waffle&quot;);
require(&quot;@nomiclabs/hardhat-web3&quot;);
require(&quot;@nomiclabs/hardhat-ethers&quot;);
require(&#x27;dotenv&#x27;).config();

task(&quot;height&quot;, &quot;Print the current block height&quot;)
  .setAction(async (taskArgs) =&gt; {
    const block_height = await web3.eth.getBlockNumber();
    console.log(`The current block height is ${block_height}`);
  });

module.exports = {
  networks: {
    hardhat: {
      forking: {
        url: process.env.Mainnet,
        blockNumber: 14297759
      }
    }
  }
};
// 高度 14297759 發生在 2022-03-01 00:00:18 (UTC+0)，選擇此數字方便後續解說
</code></pre><ol start="3"><li>為什麼要這樣設定呢？<ul><li><code>task()</code> 的程式片段目的是創造能印出目前區塊高度的指令（以 Hardhat Network 分叉出來的主網來看），關於 task 的編寫方法詳見文末的延伸閱讀</li><li><code>network</code> 項目底下，我們設定 <code>hardhat</code> 網路的相關參數，包含 archive node 的存取網址與分叉高度</li><li>由於 <code>network</code> 項目底下可以同時設定多個不同的網路，以下為簡易範例，詳細辦法請參見文末延伸閱讀</li></ul></li></ol><pre><code class="language-js">module.exports = {
  solidity: {...},
  networks: {
    arbitrum: {
      url: process.env.Arbitrum, 
      accounts: [process.env.PriKey0, process.env.PriKey1]
    },
    hardhat: {...}
  }
};
</code></pre><h2>Step 3：使用自定義的 Hardhat task <code>height</code></h2><p>目標：透過自定義的 <code>height</code> task 來確認 mainnet forking 可正常運作</p><ol><li>列出所有可用的 Hardhat task<ul><li><code>--network &quot;hardhat&quot;</code> 代表命令 Hardhat 使用 Hardhat Network</li><li>如果讀者在 <code>hardhat.config.js</code> 裡面設置其他網路，則可透過此參數隨時切換網路</li><li>我們可以發現到「<code>AVAILABLE TASKS</code>」出現了一行 <code>height Print the current block height</code> 文字，與稍早我們在 <code>hardhat.config.js</code> 撰寫的內容一致</li></ul></li></ol><pre><code class="language-Shell">$ yarn hardhat --network &quot;hardhat&quot; help
yarn run v1.22.17
Hardhat version 2.8.4

Usage: hardhat [GLOBAL OPTIONS] &lt;TASK&gt; [TASK OPTIONS]

GLOBAL OPTIONS:
  --config              A Hardhat config file.
  --emoji               Use emoji in messages.
  --help                Shows this message, or a task&#x27;s help if its name is provided
  --max-memory          The maximum amount of memory that Hardhat can use.
  --network             The network to connect to.
  --show-stack-traces   Show stack traces.
  --tsconfig            A TypeScript config file.
  --verbose             Enables Hardhat verbose logging
  --version             Shows hardhat&#x27;s version.

AVAILABLE TASKS:
  check         Check whatever you need
  clean         Clears the cache and deletes all artifacts
  compile       Compiles the entire project, building all artifacts
  console       Opens a hardhat console
  flatten       Flattens and prints contracts and their dependencies
  height        Print the current block height
  help          Prints this message
  node          Starts a JSON-RPC server on top of Hardhat Network
  run           Runs a user-defined script after compiling the project
  test          Runs mocha tests
</code></pre><ol start="2"><li>運行 <code>height</code> 指令<ul><li>由於目前 Ethereum 的最新區塊高度必定不只 14297759，因此可見我們已成功創造一個全新的 mainnet forking 環境</li></ul></li></ol><pre><code class="language-Shell">$ yarn hardhat --network &quot;hardhat&quot; height
yarn run v1.22.17
The current block height is 14297759
</code></pre><ol start="3"><li>利用 <code>node</code> 指令，開始運作 Hardhat Network 節點<ul><li><strong>請注意</strong>：這些地址與私鑰都由已知的 key derivation 過程<sup id="fnref-7"><a href="#fn-7" class="footnote-ref">7</a></sup>產生；換句話說，任何使用 Hardhat 的開發者皆知這些私鑰，因此<strong>切勿在公開網路將東西傳送進這些地址！</strong></li><li>前文已提過 Hardhat Network 預設提供 20 個各具 10000 ETH 的帳號供開發者自由使用</li><li>搭配我們現已學會的 mainnet forking 技巧，則可開始使用這些幾乎用不完的 ETH ，在自己的 local testnet 做各類開發</li></ul></li></ol><pre><code class="language-Shell">$ yarn hardhat --network &quot;hardhat&quot; node
yarn run v1.22.17
Started HTTP and WebSocket JSON-RPC server at http://127.0.0.1:8545/

Accounts
========

WARNING: These accounts, and their private keys, are publicly known.
Any funds sent to them on Mainnet or any other live network WILL BE LOST.

Account #0: 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266 (10000 ETH)
Private Key: ...

Account #1: 0x70997970c51812dc3a010c7d01b50e0d17dc79c8 (10000 ETH)
Private Key: ...

...

Account #19: 0x8626f6940e2eb28930efb4cef49b2d1f2c9c1199 (10000 ETH)
Private Key: ...

WARNING: These accounts, and their private keys, are publicly known.
Any funds sent to them on Mainnet or any other live network WILL BE LOST.
</code></pre><p>本文到此已完成所有步驟，恭喜各位讀者已學會如何使用 Hardhat 進行 mainnet forking。另一篇<a href="./hardhat-forking-2.md">文章</a>將操作簡單的範例，向有興趣的讀者展示 Hardhat Network 的有趣應用。</p><h2>Related resources</h2><ul><li>Yarn<ul><li><a href="https://classic.yarnpkg.com/en/">https://classic.yarnpkg.com/en/</a></li></ul></li><li>Hardhat<ul><li>GitHub：<a href="https://github.com/NomicFoundation/hardhat">https://github.com/NomicFoundation/hardhat</a></li><li>Mainnet forking：<a href="https://hardhat.org/hardhat-network/guides/mainnet-forking.html">https://hardhat.org/hardhat-network/guides/mainnet-forking.html</a></li><li>Configuration：<a href="https://hardhat.org/config/">https://hardhat.org/config/</a></li><li>Hardhat Network Reference：<a href="https://hardhat.org/hardhat-network/reference/">https://hardhat.org/hardhat-network/reference/</a></li><li>Creating a task：<a href="https://hardhat.org/guides/create-task.html">https://hardhat.org/guides/create-task.html</a></li><li>Hardhat Runtime Environment (HRE)：<a href="https://hardhat.org/advanced/hardhat-runtime-environment.html">https://hardhat.org/advanced/hardhat-runtime-environment.html</a></li></ul></li><li>Alchemy<ul><li><a href="https://www.alchemy.com/">https://www.alchemy.com/</a></li></ul></li><li>Ethereum on ARM<ul><li><a href="https://ethereum-on-arm-documentation.readthedocs.io/en/latest/quick-guide/about-quick-start.html">https://ethereum-on-arm-documentation.readthedocs.io/en/latest/quick-guide/about-quick-start.html</a></li></ul></li><li>Wrapped Ether<ul><li><a href="https://weth.io/index.html">https://weth.io/index.html</a></li></ul></li></ul><h2>Further reading</h2><ul><li>Infura<ul><li><a href="https://infura.io/">https://infura.io/</a></li></ul></li><li>QuickNode<ul><li><a href="https://www.quicknode.com/">https://www.quicknode.com/</a></li></ul></li><li>Truffle<ul><li>Simulate Live Networks with Forked Sandboxes：<a href="https://trufflesuite.com/blog/sandbox-forking-with-truffle-teams/index.html">https://trufflesuite.com/blog/sandbox-forking-with-truffle-teams/index.html</a></li></ul></li></ul><div class="footnotes"><hr/><ol><li id="fn-1">例如：Rinkeby、Goerli、Kintsugi 等<a href="#fnref-1" class="footnote-backref">↩</a></li><li id="fn-2">可能因不同 testnet 共識機制，而與主網略有差異，但是一般來說很罕見出現 Dapp 能夠運行於 testnet 卻無法運行於 mainnet，尤其所有網路的 EVM 實作細節均相同<a href="#fnref-2" class="footnote-backref">↩</a></li><li id="fn-3"><a href="https://hardhat.org/hardhat-network/guides/mainnet-forking.html#mainnet-forking">https://hardhat.org/hardhat-network/guides/mainnet-forking.html#mainnet-forking</a><a href="#fnref-3" class="footnote-backref">↩</a></li><li id="fn-5">透過樹梅派 4B 可以搭建歸檔節點，不以挖礦為目的來搭建歸檔節點非難事，只需要準備大容量的 SATA3 SSD 即可，詳細請參考文末的延伸閱讀 Ethereum on ARM<a href="#fnref-5" class="footnote-backref">↩</a></li><li id="fn-6">Infura、Alchemy、QuickNode 均有提供存取歸檔節點的服務，其中 Alchemy 在作者撰文時為免費服務。<a href="#fnref-6" class="footnote-backref">↩</a></li><li id="fn-7">有興趣的讀者請參見這個連結 <a href="https://hardhat.org/hardhat-network/reference/#accounts">https://hardhat.org/hardhat-network/reference/#accounts</a><a href="#fnref-7" class="footnote-backref">↩</a></li></ol></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hardhat mainnet forking：主網分叉 (2)]]></title>
            <link>https://lundao.tech/blog/hardhat-forking-2</link>
            <guid>hardhat-forking-2</guid>
            <pubDate>Wed, 23 Mar 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[利用 Hardhat 主網分叉做一些酷炫的事情]]></description>
            <content:encoded><![CDATA[<p>在上一篇<a href="./hardhat-forking-1.md">文章</a>我們已經學會了怎麼使用 Hardhat mainnet forking，但是讀者可能尚有疑惑不知道這樣的功能可以做什麼？本篇文章將延續相同主題，並給出幾個例子，向讀者展示 mainnet forking 能夠為開發過程帶來的方便性。</p><h2>範例一：與 <code>WETH9</code> 合約互動</h2><p>如同前文所述，interoperability 是 smart contract 一個相當重要的特性，而以程式的角度來看即為合約互相呼叫。假設我們今天要開發一個合約會與 Wrapped Ether（<code>WETH9</code>）<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup>合約互動，那麼會發生什麼事呢？</p><p>若無 mainnet forking 可用，則我們必需先將 <code>WETH9</code> 部屬在 local Hardhat Network （且會得到與主網不一樣的合約地址），方能與之互動、進行後續的開發流程；可想而知這就是增加複雜度，卻降低仿真度的土法煉鋼方法。</p><p>若有 mainnet forking 可用，則我們什麼都不需要做。直接與 Etherscan 上面查詢到的 <code>WETH9</code> 合約地址互動即可，完全模擬我們合約在未來上線時的操作環境。</p><p>以下將透過執行一段簡短的 JavaScript 腳本，向讀者展示要怎麼在已完成 mainnet forking 的 Hardhat Network 之內，與知名的 <code>WETH9</code> 互動。</p><ol><li>延續前文的操作環境</li><li>在 <code>hardhat_fork</code> 資料夾底下創立新資料夾 <code>scripts</code></li><li>前往 Etherscan.io 或任何你信任的 Ethereum blockchain explorer 尋找 WETH 合約<ul><li><a href="https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code">https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code</a></li></ul></li><li>將合約 ABI 儲存成 <code>contract-abi.json</code> 檔案，並放置於 <code>hardhat_fork/scripts</code> 資料夾底下<ul><li>若是使用 Etherscan，則需滾動至網頁最下方，如圖所示</li></ul></li></ol><p><img src="./weth9-contract-abi.png" alt="weth9-contract-abi"/></p><ol start="4"><li>前往這個 Gist 下載 <code>interact.js</code> 腳本，並且把它儲存在 <code>hardhat_fork/scripts</code> 資料夾底下<ul><li><a href="https://gist.github.com/a2468834/6101244f5000e467ec8904ac5f0ec41d">https://gist.github.com/a2468834/6101244f5000e467ec8904ac5f0ec41d</a></li><li>或可至 GitHub 上面 LunDAO repo 下載</li></ul></li><li>截至目前為止，<code>hardhat_fork</code> 資料夾應該要長得像這樣子<sup id="fnref-8"><a href="#fn-8" class="footnote-ref">8</a></sup></li></ol><pre><code class="language-Shell">📂 hardhat_fork
 │
 ├── 📂 scripts
 │    │
 │    ├── 📄 contract-abi.json
 │    │
 │    └── 📄 interact.js
 │
 ├── 📄 .env
 │
 └── 📄 hardhat.config.js
</code></pre><ol start="6"><li>執行指令</li></ol><pre><code class="language-Shell">$ yarn hardhat --network &quot;hardhat&quot; run scripts/interact.js
yarn run v1.22.17

Check contract status
--------------------------------------------------------------------------------
        ETH-Balance                     WETH-Balance
WETH9   7160157.033871775794435313      7160157.033871775794435313

[Step 0] Before we started
--------------------------------------------------------------------------------
Account Address             ETH-Balance     WETH-Balance
#0      0xf39f......2266    10000.000       0.000
#1      0x2feb......a6f3    4.294           13813.827

[Step 1] Account#1 deposits 3 ETH in contract
--------------------------------------------------------------------------------
Account Address             ETH-Balance     WETH-Balance
#0      0xf39f......2266    10000.000       0.000
#1      0x2feb......a6f3    1.291           13816.827

[Step 2] Account#1 sends 13 WETH to Account#0
--------------------------------------------------------------------------------
Account Address             ETH-Balance     WETH-Balance
#0      0xf39f......2266    10000.000       13.000
#1      0x2feb......a6f3    1.286           13803.827

[Step 3] Account#0 withdraws 13 WETH from contract
--------------------------------------------------------------------------------
Account Address             ETH-Balance     WETH-Balance
#0      0xf39f......2266    10012.997       0.000
#1      0x2feb......a6f3    1.286           13803.827

================================================================================
{
  hash: &#x27;0x1dfa3eee62caaf1aa06d60b9fd57d67d17fe23c9f9452c1e3284056e6fad6e48&#x27;,
  type: 2,
  accessList: [],
  blockHash: &#x27;0x3750ecaf4f7ccf733ceed460a0aeb54b3dd2373dc199ba5b420e062c5d39f165&#x27;,
  blockNumber: 14297760,
...
</code></pre><p>以下筆者將對 <code>interact.js</code> 的程式碼做一些重點解析</p><h3>Line 8-9</h3><p>開啟 mainnet forking 模式讓我們得以直接與真實的 <code>WETH9</code> 合約地址互動，不需要額外部屬其他合約。另外，<code>somebody</code> 地址則是隨機挑選的一個地址，恰巧該地址同時擁有 eth 和 weth，在接下來的操作當中可見奇效。</p><pre><code class="language-javascript">const weth9_address = &quot;0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2&quot;;
const somebody      = &quot;0x2feb1512183545f48f6b9c5b4ebfcaf49cfca6f3&quot;;
</code></pre><h3>Line 13-30</h3><p>用來讓印在 terminal 的文字看起來排版美美的函數們，並沒有特別之處</p><pre><code class="language-javascript">function addressSlicing(address) {
    /* Skip */
}

async function printAccountAndBalance(provider, contract, account0, account1) {
    /* Skip */
}
</code></pre><h3>Line 34-35</h3><p><code>hre</code>（Hardhat Runtime Environment, HRE）是一個 Hardhat Network 啟動之後，包含所有 Hardhat 套件功能的物件，詳細內容請見文末延伸閱讀。</p><p><code>hre.ethers.getSigners()</code> 回傳一個長度為 20 的 ethers.js Signer 陣列，就是前文所述的那二十個各有 10000 ETH 的帳號</p><pre><code class="language-javascript">const HRE_EOAs = await hre.ethers.getSigners();
const provider = await hre.ethers.provider;
</code></pre><h3>Line 40-43,47</h3><p>在 mainnet forking 模式之下，Hardhat Network 允許開發者發送 tx，<strong>即便你根本未持有該地址的私鑰</strong>。有了這個功能，我們可以隨意尋找任何具備我們有興趣條件的地址（EOA 或 contract address 均可），然後以它的名義發送 tx 來進行各式操作，讓 mainnet forking 的測試環境兼具高仿真度與高便利性。</p><p>除了 <code>hardhat_impersonateAccount</code> 功能之外，還有其他例如：<code>hardhat_setNonce</code>、<code>hardhat_setBalance</code>、<code>hardhat_setCode</code>、<code>hardhat_setStorageAt</code>等功能，詳細可見<a href="https://hardhat.org/hardhat-network/guides/mainnet-forking.html#customizing-hardhat-network-s-behavior">這邊</a>的說明。</p><pre><code class="language-javascript">await hre.network.provider.request({
    method: &quot;hardhat_impersonateAccount&quot;,
    params: [somebody]
});
</code></pre><h3>Line 50-56</h3><p>此 JavaScript 腳本印出 <code>WETH9</code> 的 token 總發行量與此地址的 balance，我們可見兩個數值相等且與 Etherscan 上的餘額吻合。由於 Etherscan Analytics 分頁謹顯示當日日末餘額，因此需查詢前一日餘額為準。</p><p><img src="./etherscan-analytics.png" alt="Etherscan-Analytics"/></p><h3>Line 64-68</h3><p>我們以 <code>somebody</code> 地址的名義（i.e., 使用 <code>signer_1</code> 發出 txn），向 <code>WETH9</code> 合約存款 3 eth；之所以此行為不是 invalid tx，歸功於前述的 <code>hardhat_impersonateAccount</code> 功能<sup id="fnref-9"><a href="#fn-9" class="footnote-ref">9</a></sup>，它讓我們能夠在 Hardhat Network 內以未知密鑰地址的名義發送 tx。</p><pre><code class="language-javascript">var overrides = {value : hre.ethers.utils.parseEther(&quot;3.0&quot;)};
WETH9         = WETH9.connect(signer_1);
txn_array.push(await WETH9.deposit(overrides));
await printAccountAndBalance(provider, WETH9, signer_0, signer_1);
</code></pre><h3>Line 72-80</h3><p>這個段落把 <code>Account#1</code>（即 <code>somebody</code> 地址）的 13 個 weth 轉給 <code>Account#0</code>（即 HRE 預設地址 No.0）。</p><pre><code class="language-javascript">WETH9 = WETH9.connect(signer_1);
txn_array.push(
    await WETH9.transferFrom(
        signer_1.address, 
        signer_0.address, 
        hre.ethers.utils.parseEther(&quot;13.0&quot;)
));
await printAccountAndBalance(provider, WETH9, signer_0, signer_1);
</code></pre><h3>Line 84-89</h3><p>由於傳送 tx 需要耗費 tx fee，所以我們可以發現最終印出的結果顯示：<code>Account #0</code> 和 <code>Account #1</code> 的 eth 餘額總和比最初的時候少一些。</p><h3>Line 93-97</h3><p>最後會印出稍早發送的所有 tx 的細節；讀者可以透過 <code>blockNumber</code> 查覺這些 tx 與當初指定 mainnet forking 區塊高度之間的關聯性，可見 Hardhat Network 是有在逐步長高。</p><h2>範例二：抓取 <code>public</code> 變數的歷史數據</h2><p>這個範例要解決的是另一個事情：要怎麼抓取 Ethereum 上面某個數據的歷史資料呢？</p><p>Etherscan 提供圖形化介面讓開發者可以快速查詢合約內 <code>public</code> <code>view</code>/<code>pure</code> function 的回傳值，但是如果我們有興趣的回傳值只會出現在特定 block number 呢？這時候除了使用 Dune Analytics 等網站提供的服務，我們其實可以透過 mainnet forking 的功能來自己實作。</p><p>以下將使用另一份 JavaScript 腳本，只需將前一個範例的第四步驟改為下載此腳本，即可成功執行。</p><ul><li><a href="https://gist.github.com/a2468834/71c59d580c1da21337350cdfc47e515b">https://gist.github.com/a2468834/71c59d580c1da21337350cdfc47e515b</a></li><li>或可至 GitHub 上面 LunDAO repo 下載</li><li>截至目前為止，<code>hardhat_fork</code> 資料夾應該要長得像這樣子<sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup></li></ul><pre><code class="language-Shell">📂 hardhat_fork
 │
 ├── 📂 scripts
 │    │
 │    ├── 📄 contract-abi.json
 │    │
 │    ├── 📄 interact.js
 │    │
 │    └── 📄 query.js
 │
 ├── 📄 .env
 │
 └── 📄 hardhat.config.js
</code></pre><p>執行指令之後，可見 terminal 印出類似這樣子的文字</p><pre><code class="language-Shell">$ yarn hardhat --network &quot;hardhat&quot; run scripts/query.js
yarn run v1.22.17

Method 1
----------------------------------------
Block number: 14379900
TotalSupply:  7080076.411770262795354559
----------------------------------------
Block number: 14379901
TotalSupply:  7080077.697963348707441243
----------------------------------------
Block number: 14379902
TotalSupply:  7080074.493707533508180991
...
</code></pre><p>以下筆者將對 <code>query.js</code> 的程式碼做一些重點解析</p><h3>Line 14-19,28-29</h3><p>此腳本透過循序變換 mainnet forking 的分叉高度，達成「查詢某個區間內，<code>WETH9</code> 合約的 <code>totalSupply()</code> 數值變化」</p><pre><code class="language-javascript">var config = {  method: &quot;hardhat_reset&quot;,
                params: [{
                    forking: {
                        jsonRpcUrl: process.env.Mainnet,
                        blockNumber: 0}}]
};
config.params[0].forking.blockNumber = block_i;
await hre.network.provider.request(config);
</code></pre><h3>Line 38-51</h3><p>事實上，查詢 <code>public</code> <code>view</code>/<code>pure</code> function 的歷史數據，不需要用到 mainnet forking 模式。可以單純透過呼叫合約函數，額外附加 <code>blockTag</code> 即可<sup id="fnref-5"><a href="#fn-5" class="footnote-ref">5</a></sup>。<code>method1()</code> 為使用 mainnet forking 的方法，<code>method2()</code> 則是不需使用 mainnet forking 的方法。</p><pre><code class="language-javascript">async function method2() {
    /* Skip */
}
</code></pre><h3>Line 55-56</h3><p>執行的時候記得把其中一行的註解拿掉；另外，mainnet forking 的分叉高度不能小於想要查詢<code>public</code> <code>view</code>/<code>pure</code> function 的歷史數據的區塊高度。</p><pre><code class="language-javascript">async function main() {
    // Delete one of the following comments
    //await method1();
    //await method2();
}
</code></pre><h2>Related resources</h2><ul><li>Yarn<ul><li><a href="https://classic.yarnpkg.com/en/">https://classic.yarnpkg.com/en/</a></li></ul></li><li>Hardhat<ul><li>GitHub：<a href="https://github.com/NomicFoundation/hardhat">https://github.com/NomicFoundation/hardhat</a></li><li>Mainnet forking：<a href="https://hardhat.org/hardhat-network/guides/mainnet-forking.html">https://hardhat.org/hardhat-network/guides/mainnet-forking.html</a></li><li>Configuration：<a href="https://hardhat.org/config/">https://hardhat.org/config/</a></li><li>Hardhat Network Reference：<a href="https://hardhat.org/hardhat-network/reference/">https://hardhat.org/hardhat-network/reference/</a></li><li>Creating a task：<a href="https://hardhat.org/guides/create-task.html">https://hardhat.org/guides/create-task.html</a></li><li>Hardhat Runtime Environment (HRE)：<a href="https://hardhat.org/advanced/hardhat-runtime-environment.html">https://hardhat.org/advanced/hardhat-runtime-environment.html</a></li></ul></li><li>Alchemy<ul><li><a href="https://www.alchemy.com/">https://www.alchemy.com/</a></li></ul></li><li>Ethereum on ARM<ul><li><a href="https://ethereum-on-arm-documentation.readthedocs.io/en/latest/quick-guide/about-quick-start.html">https://ethereum-on-arm-documentation.readthedocs.io/en/latest/quick-guide/about-quick-start.html</a></li></ul></li><li>Wrapped Ether<ul><li><a href="https://weth.io/index.html">https://weth.io/index.html</a></li></ul></li></ul><h2>Further reading</h2><ul><li>Infura<ul><li><a href="https://infura.io/">https://infura.io/</a></li></ul></li><li>QuickNode<ul><li><a href="https://www.quicknode.com/">https://www.quicknode.com/</a></li></ul></li><li>Truffle<ul><li>Simulate Live Networks with Forked Sandboxes：<a href="https://trufflesuite.com/blog/sandbox-forking-with-truffle-teams/index.html">https://trufflesuite.com/blog/sandbox-forking-with-truffle-teams/index.html</a></li></ul></li></ul><div class="footnotes"><hr/><ol><li id="fn-3">關於什麼是 Wrapped Ether？請參考文末延伸閱讀，或請讀者自行查詢其他網路資料。<a href="#fnref-3" class="footnote-backref">↩</a></li><li id="fn-8">有省略一些與本文無關的檔案與資料夾<a href="#fnref-8" class="footnote-backref">↩</a></li><li id="fn-9"><a href="https://hardhat.org/hardhat-network/reference/#hardhat-impersonateaccount">https://hardhat.org/hardhat-network/reference/#hardhat-impersonateaccount</a><a href="#fnref-9" class="footnote-backref">↩</a></li><li id="fn-4">有省略一些與本文無關的檔案與資料夾<a href="#fnref-4" class="footnote-backref">↩</a></li><li id="fn-5"><code>blockTag</code> 是 ethers.js 的語法，web3.js 的 API 使用方法可能有所不同<a href="#fnref-5" class="footnote-backref">↩</a></li></ol></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[基本功：从合约看 token 数量]]></title>
            <link>https://lundao.tech/blog/total-tokens-looksrare</link>
            <guid>total-tokens-looksrare</guid>
            <pubDate>Sun, 13 Mar 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[不知道你是否和我一样，总是担心关注的 token 增发，但又对 CoinGecko 或者 Etherscan 上的数字心怀疑虑。以太坊上每个 token 都是独立的合约，那就深入合约来探个究竟吧。Code is Law！]]></description>
            <content:encoded><![CDATA[<p>不知道你是否和我一样，总是担心关注的 token 增发，但又对 CoinGecko 或者 Etherscan 上的数字心怀疑虑。以太坊上每个 token 都是独立的合约，那就深入合约来探个究竟吧。Code is Law！ </p><p>让我们以最近发行的 LooksRare 项目为例。</p><table><thead><tr><th align="center"><img src="./coingecko.png" alt="coingecko"/></th></tr></thead><tbody><tr><td align="center">2022-01-16 CoinGecko 截图</td></tr><tr><td align="center"><img src="./etherscan-looks.png" alt="etherscan"/></td></tr><tr><td align="center">2022-01-16 Etherscan 截图</td></tr></tbody></table><p>可以从 CoinGecko 看到有 <code>Total Supply</code> 和 <code>Max Supply</code> 两个概念。从 Etherscan 的 token 页面又会看到 <code>Max Total Supply</code>。 这三个数字并不一致。我并不清楚 CoinGecko 和 Etherscan 的具体机制，所以直接看看这个 token 的合约吧。 </p><pre><code class="language-js">    // File 1 of 7 : LooksRareToken.sol
    constructor(
        address _premintReceiver,
        uint256 _premintAmount,
        uint256 _cap
    ) ERC20(&quot;LooksRare Token&quot;, &quot;LOOKS&quot;) {
        require(_cap &gt; _premintAmount, &quot;LOOKS: Premint amount is greater than cap&quot;);
        // Transfer the sum of the premint to address
        _mint(_premintReceiver, _premintAmount);
        _SUPPLY_CAP = _cap;
    }
</code></pre><p>以太坊智能合约部署后，首先运行的就是 <code>constructor</code> 函数。可以看出 LOOKS 的 <code>constructor</code> 有三个参数。 </p><table><thead><tr><th align="center"><img src="./constructor.png" alt="constructor"/></th></tr></thead><tbody><tr><td align="center"><a href="https://etherscan.io/address/0xf4d2888d29d722226fafa5d9b24f9164c092421e#code">合约地址页面中 Contract Tab 最下面的部分</a></td></tr></tbody></table><p>在 Etherscan 上找出<a href="https://etherscan.io/address/0xf4d2888d29d722226fafa5d9b24f9164c092421e">该合约的信息</a>，找出 <code>Constructor Arguments</code>。 看到 <code>_cap</code> 传入的值为 <code>1000000000000000000000000000</code>，这个值除 10^18 就是 1000 mil，就能和 CoinGecko 中的<code>Max Supply</code>对应上了。</p><pre><code class="language-js">    // File 3 of 7 : ERC20.sol
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }
</code></pre><p>为什么要除以 10^18 呢？ 这是因为普通用户看到的 1 个 token，其实是 <code>10^decimals</code> 个最小单位。这样，合约程序只处理整数，而在界面上可以显示小数（例如 0.1 或 0.01）个的 token。</p><p>那么 CoinGecko 的 <code>Total Supply</code> 又是什么呢？ 这个数字和 Etherscan 的 <code>Max Total Supply</code> 是接近的，都是 231.xxx mil。有理由猜测这是一个动态的数字，两个网站都想监测这个动态数字，但不太同步。有了这个猜想后，再回头看看 LOOKS 的合约。</p><pre><code class="language-js">    // File 3 of 7 : ERC20.sol
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }
</code></pre><p>符合 <code>ERC20</code> 标准的 token 都有只读函数 <code>totalSupply()</code>。这是一个 <code>view</code> 函数，可以读取链上 state，但不会写入。随着链上不断出现新 block，<code>view</code> 函数的返回值也可能变化。在 Etherscan 上可以直接读取，可以发现确实是 231.xxx mil。</p><p>之前注意到的 <code>_cap</code> 只是初始化 <code>_SUPPLY_CAP</code> 变量，并没有改变 <code>_totalSupply</code>。一个值得思考的小问题是：当合约刚部署的时候，totalSupply 会是多少呢？ Etherscan 上调用 <code>view</code> 函数，应该还不能指定 block number（可以通过支持历史信息的 json rpc 查询，如 alchemyapi）。</p><p>一点题外话：token 的发行量信息是如此重要，任何 ERC20 token 都需要提供 <code>totalSupply()</code> 接口。即使是非 ERC20 token，如 2018 年的 <a href="https://etherscan.io/address/0xb3775fb83f7d12a36e0475abdd1fca35c091efbe">PowH3D (P3D)</a>，也提供了 <code>totalSupply()</code> 哦。</p><p>ERC20： <a href="https://eips.ethereum.org/EIPS/eip-20">https://eips.ethereum.org/EIPS/eip-20</a></p><p><code>view</code>函数： <a href="https://medium.com/taipei-ethereum-meetup/solidity-weekly-11-70c5208a3bf1">https://medium.com/taipei-ethereum-meetup/solidity-weekly-11-70c5208a3bf1</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[MEV - 最大可提取價值]]></title>
            <link>https://lundao.tech/blog/mev</link>
            <guid>mev</guid>
            <pubDate>Sun, 13 Feb 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[解釋 MEV (最大可提取價值) 的成因以及原理，並且簡述目前的解決方案。]]></description>
            <content:encoded><![CDATA[<p>最大可提取價值 (Maximal Extractable Value, MEV) 是一種透過改變交易順序來獲得利益的方法。比如說礦工可以在 Uniswap 交易中發現可以營利的機會並且自動化的執行特定的策略來營利，而這樣的行為有可能會讓原本的交易者虧損，但有趣的是這也沒有違反區塊鏈的規則，只是利用區塊鏈來完成的一種行為，當然這樣的行為有可能傷害區塊鏈的生態系。本文將會以 Ethereum 作為範例來講解這樣行為的運作原理。</p><p>首先我們需要了解在 Ethereum 交易是怎麼被執行的。</p><h2>發生交易前，你的 tx 在哪裡？</h2><p>Alice 想要送出一個交易在 Uniswap 上面將 3000 USDC 換成 1 ETH，當按下 MetaMask 上面的送出之後，實際上他的交易是怎麼樣被處理的呢？</p><p>「在 Uniswap 上用 3000 USDC 交換 1 ETH」這件事情我們可以看成是 Alice 的意圖，一件他想要執行的事情，稱為 pending transaction。這個 pending tx 會被傳送到 Ethereum 上面的節點，而節點之間會互相交換 pending tx，盡可能的讓更多節點知道使用者有這個需求，這些還沒被打包到區塊裡面的 pending tx 就會被放到節點特定區域先儲藏起來，這個區域叫做 mempool。而每個節點因為會收取來自不同地方的 pending tx，所以每個節點的 mempool 內容可能都不一樣，排序也會不一樣。</p><p><img src="pending-tx.png" alt="pending tx"/></p><p>節點有幾種不同的型態，而礦工也是節點的一種型態，他的工作是負責把 mempool 裡面的 pending tx 打包起來變成一個區塊，然後跟其他礦工一起競爭記帳權，當其中一個礦工爭取到了記帳權後，這個區塊就會被發佈出去，此時 Alice 的 pending tx 才變成一個已經上鏈的交易 (transaction)。</p><h2>礦工怎麼挑選 pending tx</h2><p>因為包裝、發布區塊是一件利益導向的事情，每發布一個區塊礦工可以得到固定的區塊獎勵，還有在這個區塊裡面的交易所提供的交易費。比如說 14143088 這個區塊總共有 360 個被打包進去的交易，而發布這個區塊可以得到的固定獎勵是 2 ETH (依照今天的匯率是 16 萬台幣)，而後面兩個數字 <code>2.410435284410848966 - 2.13247814979521476 ~= 0.2 ETH</code> 則是所有交易提供的交易費加總。為什麼有兩個數字涉及到 EIP-1559 這邊就不先深入討論。</p><p><img src="./block-14143088.png" alt="block 14143088"/></p><p>至於礦工是怎麼挑選哪些交易要被放到這個區塊裡面，基本上就是前面講的利益導向。一般的情況，礦工會排序所有交易裡面提供的交易費，並且優先打包提供比較多交易費的交易。所以交易費提供較多的交易會排序在前面被打包進去區塊裡面，如果你交易費提供的少，就會過了很久等到所有交易都消化的差不多才會輪到你。</p><p>但這邊是指一般的情況，實際上要把什麼交易打包進去區塊並沒有限制，礦工可以用各種方式決定哪些區塊要打包。</p><h2>三明治攻擊 (Sandwich Attack)</h2><p>由於礦工可以自行決定哪些交易要被打包進去區塊裡面，而這些 pending tx 在 mempool 裡面是一個公開的資訊，一般節點會提供公開的方法讓任何人可以查詢目前 mempool 裡面有哪些交易正在等待被打包。</p><p>這邊就出現了一些可以操作的空間。</p><p>前面舉例的 Alice 打算用 3,000 USDC 交換 1 ETH，而每次的交易都會影響下一次交易的價格。</p><p>這樣的交易內容是可以直接從 pending tx 中被解析出來。如果有人發現一種自動的邏輯，他分析 mempool 裡面的每一個交易，並且找到一個方法可以從中獲利，比如說 Bob 發現 mempool 裡面有 Alice 這筆交易，而且他只要可以排序這些交易的執行順序：</p><ol><li>Bob 先用 6,000 USDC 買 2 ETH 導致 ETH 漲價，影響到 Alice 的交易</li><li>Alice 用 3,000 USDC 只能買到 0.8 ETH，此時 ETH 再度漲價</li><li>Bob 再次把 2 ETH 賣掉，由於 Alice 把價格也墊高了，所以 Bob 可以把 2 ETH 賣到 6,600 USDC</li></ol><p><img src="./mev.png" alt="MEV"/></p><p>這樣 Bob 只要可以排序交易，第一步花費的 6000 USDC 在第三步就賺回來了，這樣就可以憑空賺 600 USDC，這樣的行為我們稱為三明治攻擊 (Sandwich Attack)</p><p>但是要怎麼更動交易順序呢？這就是一件礦工（或是任何可以改變交易的人）能做到的事情了。當礦工發現一個交易在他前後夾擊兩個額外的交易就可以從中獲利時，同時他還要有能力讓當下這個區塊是能夠由他取得記帳權的。所以實際發生的流程會是：</p><ol><li>礦工發現可提取價值的交易</li><li>自動產生夾擊的交易並且排入區塊內</li><li>取得該區塊的記帳權並且獲利</li></ol><p>而第三步當你有更高的算力時，能夠執行成功的機率越大。如果發現這個機會的那個區塊沒有取得記帳權，這個機會就消失了，他原本用來夾擊的兩個交易在下個區塊就不會再出現。比如說一個礦工（或是礦池、礦場）有全網 20% 的算力，如果在每次他發現有利可圖的交易時都自動的發出夾擊交易企圖獲利，透過他相對高的算力累積下來可能就會是很大一筆收益，即時他的算力沒辦法讓他每次都能夠取得記帳權。</p><p>這樣的三明治攻擊行為被稱為 Miner Extractable Value (MEV) 或是 Maximal Extractable Value，而 MEV 只要是透過變更交易順序就可以歸類到此種行為，除了三明治攻擊之外還有更簡單的 MEV 方式如 front running。</p><h2>Front running</h2><p>front running 是只要偵測到特定單一筆交易發現可以獲利時，就會發出一模一樣的交易，但更高 gas 的交易來獲利，而執行後可能原本執行交易的人的交易就會失敗（或是減少獲利）。</p><p>front running 的行為如果不是礦工也可以做到，只要花費大量的 gas 即可。我們用一個清算的例子來看看 front running 的 MEV 會怎麼進行。</p><ol><li>Alice 抵押在 Compound 的 100 ETH 因為抵押品不足的原因要被清算了，Compound 以市價 1 ETH = 3000 USDC 的 95% 拍賣 Alice 的 100 ETH，原本價值 300,000 USDC 打折後只剩 285,000 USDC。</li><li>Bob 見到此機會立刻用 285,000 USDC 想要買下 100 ETH，並且將 gas 設定成 50，將交易送出。</li><li>Chris 作為一個監聽 mempool 的人，察覺到了一筆清算交易發到了 mempool，即時計算後得知此交易可獲利 5%，所以發出了一筆跟 Bob 一模一樣的交易，用 285,000 USDC 來買下 100 ETH，並且把 gas 加倍成 100 來企圖蓋過原本的交易，並且發出了交易。</li><li>此時有全網 20% 算力的礦工 Dexter 同樣也發現了此機會，mempool 裡面有兩筆交易都想透過清算賺錢，所以他也發了一模一樣的清算交易，但是他是礦工，所以直接把自己的交易放到接下來要送出的區塊內，並且不發到 mempool 裡面直接自己競爭記帳權。</li><li>最終的結果 Dexter 透過自己 20% 的算力，在這次競爭中獲得了利潤，他笑了笑，礦工的快樂就是如此樸實無華且枯燥。</li></ol><p>由於利益的驅動並且 mempool 是公開的情況下，會有很多人撰寫許多非常有彈性的腳本來監控 mempool，當他發現排序交易可以帶來利益時，就會自動的排序交易來獲利。這樣就會變成機器人大戰，無數的機器人監控著 mempool，發現賺錢機會就會自動的排序交易，如果 MEV 發起者不是礦工，所以需要把交易送回 mempool 時，監控著 mempool 的其他人看到你新發出的交易時，同樣也會毫不留情的再出發新的交易企圖獲得你的收益。</p><p>所以只要你踏入了 mempool 就像踏入了三體的黑暗森林一樣，當你發出意圖或是信號時，強大的掠食者就會撲面而來。</p><h2>實際發生的 MEV 案例</h2><p>Flashbots 的 <a href="https://explore.flashbots.net/leaderboard">MEV Explore</a> 提供了一個排名可以偵測出單一交易的 MEV，所以可以從這邊來看到一些透過 front running 的行為，不過三明治攻擊因為涉及到多筆交易，所以在這個網站上就沒辦法偵測到。目前在網站上所追蹤到最高的一次 MEV 是交易 <a href="https://etherscan.io/tx/0xd70b42daec5bb9ac6e5df3d25d309f186db50df701f667e1f20b22448ea27d41">0xd70b...7d41</a> 從中獲取了高達三百萬美金的利潤。</p><p>這個交易結合了閃電貸 (Flashloan) 來達成這次的 MEV 行為，往後我們可以更深入的探討閃電貸。</p><p>Uniswap 或其他有考慮到這樣行為的智能合約會實作一些機制來防範這種行為，但是這種攻擊如果是自動發動的情況下，任何沒有考慮 MEV 行為的智能合約都有可能自動的成為提取價值的對象。</p><h2>解決方案</h2><p>有些方法是「打不過就加入他」，<a href="https://www.edennetwork.io/">Eden Network</a> 發行了代幣，當你加入他們的經濟體制後，他會幫你優先發送交易，同時，你也成為了掠食者。</p><p><a href="https://cowswap.exchange/">CowSwap</a> 讓你簽署一個 <a href="https://yurenju.medium.com/perp-meta-tx-e53cfb65367">meta transaction</a>，並且在鏈下進行訂單的撮合，如果撮合成功就直接把交易透過無法發動 MEV 的方式發布上鏈，如果沒辦法鏈下撮合成功，則會透過鏈上的交易所進行交易，但是會直接送到由 CowSwap 所管理的節點，不會暴露在公開的 mempool 上面，但是撮合機制就變成不是在鏈上運行，減低了去中心化的程度。</p><p>而 <a href="https://ethereum.org/en/developers/docs/mev/#mev-extraction-flashbots">Flashbots</a> 提供了修改過後的 go-ethereum 讓交易直接送給礦工，而不會暴露在 mempool，而諷刺的是目前很大一部分的 MEV 攻擊行為都是透過 flashbots 達成。</p><p>你有知道其他更好的解決方案嗎？歡迎到 LunDAO 的 <a href="https://github.com/lun-dao/LunDAO/discussions/76">GitHub Discussion</a> 討論！</p><h2>注釋</h2><ul><li>目前 Miner Extractable Value 逐漸的採用一個新的名詞 Maximal Extractable Value 來取代來更準確的描述這樣的行為，詳情請見 <a href="https://explore.flashbots.net/faq">Why MEV as Maximal Extractable Value instead of Miner Extractable Value?</a> </li></ul>]]></content:encoded>
        </item>
    </channel>
</rss>